# HNDSI Basic Network Function Prototypes
# Jonathan H. Morgan
# 3 September 2021

# Basic Functions: More Functions to Be Added
#   netread
#   netwrite

#########################
#   GENERAL FUNCTIONS   #
#########################

#Options
options(stringsAsFactors = FALSE)
options(mc.cores = parallel::detectCores())

###############################
#   EXAMPLE CASE: AHS_WPVAR   #
###############################

setwd('/Users/jonathan.h.morgan/Desktop/DNAC/IDEANet/Data_Scripts')
import_data <- function(file_csv) {
  
  # Installing Necessary Packages 
    list.of.packages <- c('readr')
    new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
    if(length(new.packages)) install.packages(new.packages)
    rm(list.of.packages, new.packages)
    
  # Reading-In CSV with readr
    file_csv <- paste0(file_csv, '.csv')
    base_data <- readr::read_csv(file_csv, col_names = TRUE)
    
  # Creating Stacked Edgelist
    communities <- vector('list', length(unique(base_data$commcnt)))
    community_ids <- sort(unique(base_data$commcnt))
    names(communities) <- community_ids
    
    for (i in seq_along(communities)) {
      community <- base_data[base_data$commcnt == community_ids[[i]], ]
      egos <- sort(unique(community$ego_nid))
      
      alters <- vector('list', length(egos))
      names(alters) <- egos
      
      for (j in seq_along(egos)) {
        ego <- community[community$ego_nid == egos[[j]], ]
        m_friends <- as.data.frame(as.integer(ego[,c(4:8)]))
        m_friends <- cbind('Male', m_friends)
        colnames(m_friends) <- c('gender','alter_id')
        
        f_friends <- as.data.frame(as.integer(ego[,c(14:18)]))
        f_friends <- cbind('Female', f_friends)
        colnames(f_friends) <- c('gender','alter_id')
        
        alter_net <- rbind(m_friends, f_friends)
        alter_net <- cbind(egos[[j]], alter_net)
        alter_net <- cbind(community_ids[[i]], alter_net)
        colnames(alter_net)[c(1:2)] <- c('commcnt', 'ego_nid')
        
        alters[[j]] <- alter_net
        
        rm(alter_net, ego, m_friends, f_friends)
      }
      
      communities[[i]] <- do.call("rbind", alters)
      
      rm(community, egos, alters)
    }
  
  # Assigning communities edglist to the Global Environment
    assign(x = 'communities_edgelist', value = communities,.GlobalEnv)  
    
  return(base_data)
}

base_data <- import_data('ahs_wpvar')

# Focusing on Community One for Demonstration Purposes
  community_1 <- communities_edgelist[[1]]
  
# Converting the Community 1 network into an Adjacency List for Testing
  adj_matrix <- network::as.matrix(network,matrix.type="adjacency")

################
#   netwrite   #
################
  
# Notes:
#   nodelist assumes a single vector of node labels/ids. Numeric ids are generated by the function that are used when creating the network objects.
#   https://igraph.org/r/doc/get.edge.ids.html
  
  
# Currently Supported Packages (Will Add Pajek, ORA, UCINet, etc)
  support_packages <- c('igraph', 'network')
  
netwrite <- function(adjacency=FALSE, adjacency_matrix=FALSE, nodelist=FALSE, 
                     weights=FALSE, i_elements, j_elements, package='igraph', missing_code=99999, 
                     weight_type='frequency', directed='TRUE', net_name='network') {
  # Installing Necessary Packages 
    list.of.packages <- c('dplyr')
    new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
    if(length(new.packages)) install.packages(new.packages)
    rm(list.of.packages, new.packages)
    
  # If an adjacency network, create a network
    if (adjacency == TRUE) {
      adj_matrix <- adjacency_matrix
      if (dim(adj_matrix)[[1]] != dim(adj_matrix)[[2]]){
        test <- adj_matrix[,c(2:ncol(adj_matrix))]
      }else{
        adj_matrix <- adj_matrix[,]
      }
      
      if (package == 'igraph') {
        if(directed == TRUE){
         network <- igraph::graph_from_adjacency_matrix(adj_matrix, mode=c('directed'), diag = TRUE)
        }else{
          network <- igraph::graph_from_adjacency_matrix(adj_matrix, mode=c('undirected'), diag = FALSE)
        }
      }else{
        network <- network::
        
      }
    }else{
      edgelist <- edgelist[,]
    }
  
  # Creating Canonical Node and Edgelists
    if(weights==FALSE){
      edgelist <-as.data.frame(cbind(i_elements, j_elements))
      edgelist <-cbind(edgelist, rep(1,nrow(edgelist)))
      colnames(edgelist)[[3]] <- c('weight')
    }else{
      edgelist <-as.data.frame(cbind(i_elements, j_elements, weights))
    }
    
    edgelist <- edgelist[!(rowSums(is.na(edgelist))), ]
    edgelist <- edgelist[edgelist$i_elements != missing_code & edgelist$j_elements != missing_code, ] 
    edgelist <- cbind(seq(1,nrow(edgelist), 1), edgelist)
    colnames(edgelist)[[1]] <- c('Obs_ID')
  
    if(nodelist==FALSE) {
      nodes <- as.data.frame(sort(unique(c(edgelist$i_elements, edgelist$j_elements))))
      nodes <- cbind(seq(1,nrow(nodes),1), nodes)
      colnames(nodes) <- c('id', 'label')
      
      senders <- edgelist[c(1:2)]
      colnames(senders)[[2]] <- c('label')
      senders <- dplyr::left_join(senders, nodes, by='label')
      colnames(senders)[c(2,3)] <- c('i_elements', 'i_id')
      
      targets <- edgelist[c(1,3,4)]
      colnames(targets)[[2]] <- c('label')
      targets <- dplyr::left_join(targets, nodes, by='label')
      colnames(targets)[c(2,4)] <- c('j_elements', 'j_id')
      targets <- targets[c(1,2,4,3)]
      
      edgelist <- dplyr::left_join(senders, targets, by='Obs_ID')
      
      edgelist <- edgelist[order(edgelist$i_id, edgelist$j_id), ]
      
      rm(senders, targets)
    }else{
      nodes <- nodelist[,]
      
      nodes <- cbind(seq(1,nrow(nodes),1), nodes)
      colnames(nodes) <- c('id', 'label')
      
      senders <- edgelist[c(1:2)]
      colnames(senders)[[2]] <- c('label')
      senders <- dplyr::left_join(senders, nodes, by='label')
      colnames(senders)[c(2,3)] <- c('i_elements', 'i_id')
      
      targets <- edgelist[c(1,3,4)]
      colnames(targets)[[2]] <- c('label')
      targets <- dplyr::left_join(targets, nodes, by='label')
      colnames(targets)[c(2,4)] <- c('j_elements', 'j_id')
      targets <- targets[c(1,2,4,3)]
      
      edgelist <- dplyr::left_join(senders, targets, by='Obs_ID')
      
      edgelist <- edgelist[order(edgelist$i_id, edgelist$j_id), ]
      
      rm(senders, targets)
    }
    
  # igraph
    if(package=='igraph') {
      # Installing Necessary Packages 
        list.of.packages <- c('igraph')
        new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
        if(length(new.packages)) install.packages(new.packages)
        rm(list.of.packages, new.packages)
      
      # Make Zero-Indexed
        nodes$id <- nodes$id - 1
        edgelist$i_id <- edgelist$i_id - 1
        edgelist$j_id <- edgelist$j_id - 1
        
      # Make Weights Reflect Frequency Rather than Distance
        if(weight_type == 'frequency') {
          edgelist$weight <- 1/edgelist$weight
        }else{
          edgelist$weight <- edgelist$weight
        }
        
      # Creating igraph object
        colnames(nodes)[[2]] <- c('attr')
        g <- igraph::graph_from_data_frame(d = edgelist[c(3,5)], directed = F, vertices = nodes) 
        
      # Adding edge weights
        igraph::edge.attributes(g)$weight <- edgelist$weight
        
    }else{
      edgelist <- edgelist[,]
    }
    
  # networks
    if(package=='network') {
      # Installing Necessary Packages 
        list.of.packages <- c('network')
        new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
        if(length(new.packages)) install.packages(new.packages)
        rm(list.of.packages, new.packages)
        
      # Make Weights Reflect Distance Rather than Frequency
        if(weight_type != 'frequency') {
          edgelist$weight <- 1/edgelist$weight
        }else{
          edgelist$weight <- edgelist$weight
        }
      
      # Creating sna networks to isolate network components
        g <- network::network.initialize(nrow(nodes), directed = as.logical(directed))
        
      # Adding Edges
        el <- edgelist[c(3,5)]
        el[] <- lapply(el, as.character)
        g <- network::add.edges(g, el[[1]],el[[2]])
        
      # Adding Weights
        network::set.edge.value(g,"weight", edgelist$weight)
    }else{
      edgelist <- edgelist
    }
  
  # Outputting Network Objects
    assign(x = 'edgelist', value = edgelist,.GlobalEnv)  
    assign(x = 'nodelist', value = nodes,.GlobalEnv)  
    assign(x = net_name, value = g,.GlobalEnv)  
}

netwrite(nodelist=FALSE, weights=FALSE, community_1$ego_nid, community_1$alter_id, package='network', missing_code=99999, 
         weight_type='frequency', directed='TRUE', net_name='network')

plot(network)

###############
#   netread   #
###############

netread <- function(package="network", network_object=network) {
  # Network Control Logic
    if(package == "network"){
      # Getting Edgelist
        edges <- as.data.frame(network::as.edgelist(network_object))
        colnames(edges) <- c('i_id', 'j_id')
        
      # Checking if there are edge values
        if(length(network::list.edge.attributes(network_object)[network::list.edge.attributes(network_object) != "na"]) >= 1){
          edge_attribute <- network::list.edge.attributes(network_object)[network::list.edge.attributes(network_object) != "na"]
          edge_value <- network::get.edge.value(network_object, edge_attribute, unlist = TRUE, na.omit = TRUE, null.na = FALSE, deleted.edges.omit = TRUE)
          edges$weight <- edge_value
        }else{
          edges$weight <- 1
        }
        
      # Extracting Nodelist 
        nodes <- network::get.vertex.attribute(network_object, "vertex.names")
        nodes <- as.data.frame(cbind(seq(1, length(nodes), 1), nodes))
        colnames(nodes) <- c('id', 'label')
        rm(edge_value)
    }else if (package == 'igraph'){
      # Getting Edgelist: iGraph
        edges <- as.data.frame(igraph::as_edgelist(network_object, names=FALSE))
        colnames(edges) <- c('i_id', 'j_id')
        
      # Checking if there are edge values
        if (length(igraph::get.edge.attribute(network_object)) > 0) {
         edge_values <- as.data.frame(igraph::get.edge.attribute(network_object))
         edges <- cbind(edges, edge_values)
        }else{
          edges$weight <- 1
        }
        
      # Extracting nodelist
        nodes <- as.data.frame(igraph::get.vertex.attribute(network_object))
        colnames(nodes)[[1]] <- c('id')
        nodes$id <- as.numeric(nodes$id)
        nodes$id <- nodes$id + 1
        rm(edge_values)
    } else {
      network_object <- network_object
      print('Package Not Supported')
    }
  
    # Outputting Network Objects
      assign(x = 'edges', value = edges,.GlobalEnv)  
      assign(x = 'nodes', value = nodes,.GlobalEnv)  
}

netread(package='network', network_object=network)

#############
#   NOTES   #
#############


