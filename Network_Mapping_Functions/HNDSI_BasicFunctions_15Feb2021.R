# HNDSI Basic Network Function Prototypes
# Jonathan H. Morgan
# 22 September 2021

# Basic Functions: More Functions to Be Added
#   netread
#   netwrite

#########################
#   GENERAL FUNCTIONS   #
#########################

#Options
options(stringsAsFactors = FALSE)
options(mc.cores = parallel::detectCores())

###############################
#   EXAMPLE CASE: AHS_WPVAR   #
###############################

setwd('/Users/jonathan.h.morgan/Desktop/DNAC/IDEANet/Data_Scripts')
import_data <- function(file_csv) {
  
  # Installing Necessary Packages 
    list.of.packages <- c('readr')
    new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
    if(length(new.packages)) install.packages(new.packages)
    rm(list.of.packages, new.packages)
    
  # Reading-In CSV with readr
    file_csv <- paste0(file_csv, '.csv')
    base_data <- readr::read_csv(file_csv, col_names = TRUE)
    
  # Creating Stacked Edgelist
    communities <- vector('list', length(unique(base_data$commcnt)))
    community_ids <- sort(unique(base_data$commcnt))
    names(communities) <- community_ids
    
    for (i in seq_along(communities)) {
      community <- base_data[base_data$commcnt == community_ids[[i]], ]
      egos <- sort(unique(community$ego_nid))
      
      alters <- vector('list', length(egos))
      names(alters) <- egos
      
      for (j in seq_along(egos)) {
        ego <- community[community$ego_nid == egos[[j]], ]
        m_friends <- as.data.frame(as.integer(ego[,c(4:8)]))
        m_friends <- cbind('Male', m_friends)
        colnames(m_friends) <- c('gender','alter_id')
        
        f_friends <- as.data.frame(as.integer(ego[,c(14:18)]))
        f_friends <- cbind('Female', f_friends)
        colnames(f_friends) <- c('gender','alter_id')
        
        alter_net <- rbind(m_friends, f_friends)
        alter_net <- cbind(egos[[j]], alter_net)
        alter_net <- cbind(community_ids[[i]], alter_net)
        colnames(alter_net)[c(1:2)] <- c('commcnt', 'ego_nid')
        
        alters[[j]] <- alter_net
        
        rm(alter_net, ego, m_friends, f_friends)
      }
      
      communities[[i]] <- do.call("rbind", alters)
      
      rm(community, egos, alters)
    }
  
  # Assigning communities edglist to the Global Environment
    assign(x = 'communities_edgelist', value = communities,.GlobalEnv)  
    
  return(base_data)
}

base_data <- import_data('ahs_wpvar')

# Focusing on Community One for Demonstration Purposes
  community_1 <- communities_edgelist[[1]]
  community_2 <- communities_edgelist[[2]]
  
################
#   netwrite   #
################
  
# Notes:
#   nodelist assumes a single vector of node labels/ids. Numeric ids are generated by the function that are used when creating the network objects.
#   https://igraph.org/r/doc/get.edge.ids.html
  
# Currently Supported Packages (Will Add Pajek, ORA, UCINet, etc)

# Urgent To Do Items (27 September 2021):
  # Implement expanded network measures list for adjacency list
  # Test function on more and larger networks

# System Measures to Implement
  # Degree Distribution
  # Number of Components 
  # Proportion Largest Component
  # Diameter
  # Average Euclidean Distance
  # Clustering Coefficient
  # Triad Census
  # Flow Hiearchy (Directed): Flow hierarchy is defined as the fraction of edges not participating in cycles in a directed graph
  
  support_packages <- c('igraph', 'network')
  
  netwrite <- function(data_type = c('edgelist'), adjacency_matrix=FALSE, adjacency_list=FALSE,
                       nodelist=FALSE, i_elements=FALSE, j_elements=FALSE, weights=FALSE,
                       package='igraph', missing_code=99999, weight_type='frequency', 
                       directed=TRUE, net_name='network') {
    
  # Installing Necessary Packages 
    list.of.packages <- c('dplyr', 'igraph', 'network')
    new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
    if(length(new.packages)) install.packages(new.packages)
    rm(list.of.packages, new.packages)
    
  # Setting Data Type: Adjacency Matrix, Adjacency List, or Edgelist
    if(data_type == 'adjacency_matrix'){
      # Checking for ID Column
        if (dim(adjacency_matrix)[[1]] != dim(adjacency_matrix)[[2]]){
          adjacency_matrix <- adjacency_matrix[,c(2:ncol(adjacency_matrix))]
        }else{
          adjacency_matrix <- adjacency_matrix[,]
        }    
      
      # Generating Network Object
        if (package == 'igraph') {
          if(directed == TRUE){
            # Generating directed graph
              g <- igraph::graph_from_adjacency_matrix(adjacency_matrix, mode=c('directed'), diag = TRUE)
              
            # Creating Nodes File with Node-Level Measures
              edges <- as.data.frame(igraph::as_edgelist(g, names=FALSE))
              nodes <- as.data.frame(sort(unique(c(edges$V1, edges$V2))))
              colnames(nodes) <- c('id')
              nodes$id <- nodes$id - 1
              
            # Create an alternate closeness function
              closeness <- function(g){ 
                geo <- 1/igraph::distances(g, mode='out')
                diag(geo) <- 0 # Define self-ties as 0
                apply(geo, 1, sum) # Return sum(1/geodist) for each vertex
              }
              
            # Reachablility function (Eliminate Loops, reaching yourself isn't that useful)
              reachable <- function(g){
                # Isolating the node's ego-network, the number of reachable nodes, and calculating 
                # the proportion of the total
                  proportion_reachable <- vector('numeric', nrow(nodes))
                  if(directed == TRUE){
                    for(i in seq_along(proportion_reachable)){
                      # Isolating connected vertices
                        ego_net <- igraph::subcomponent(g, v=igraph::V(g)[[i]], mode = c("out"))
                    
                      # Eliminating self-loops
                        ego_net <- ego_net[ego_net != igraph::V(g)[[i]]]
                    
                      # Calculating the proportion reachable
                        proportion_reachable[[i]] <- length(ego_net)/nrow(nodes)
                      rm(ego_net)
                  }
                  }else{
                    for(i in seq_along(proportion_reachable)){
                      # Isolating connected vertices
                        ego_net <- igraph::subcomponent(g, v=igraph::V(g)[[i]], mode = c("all"))
                    
                      # Eliminating self-loops
                        ego_net <- ego_net[ego_net != igraph::V(g)[[i]]]
                    
                      # Calculating the proportion reachable
                        proportion_reachable[[i]] <- length(ego_net)/nrow(nodes)
                        rm(ego_net)
                    }
                  }
                
                # Writing to global environment
                  assign(x = 'reachability', value = proportion_reachable,.GlobalEnv)  
              }
              
            # Adding Node-Level Measures
              total_degree <- igraph::degree(g, mode='all', loops=FALSE)
              weighted_degree <- igraph::strength(g, mode='all', loops=FALSE)
              in_degree <- igraph::degree(g, mode='in', loops=FALSE)
              out_degree <- igraph::degree(g, mode='out', loops=FALSE)
              closeness <- closeness(g)
              betweenness <- igraph::betweenness(g, directed=as.logical(directed))
              bonpow <- igraph::bonpow(g, loops=FALSE, exponent = 0.75)
              eigen_cen <- igraph::eigen_centrality(g, directed=as.logical(directed), scale=FALSE)$vector
              constraint <- igraph::constraint(g)
              reachability <- reachable(g)
              
              nodes <- as.data.frame(cbind(nodes, total_degree, weighted_degree, in_degree, out_degree, 
                                           closeness, betweenness, bonpow, eigen_cen, constraint, reachability))
          }else{
            # Generating undirected graph
              g <- igraph::graph_from_adjacency_matrix(adjacency_matrix, mode=c('undirected'), diag = FALSE)
              
            # Creating Nodes File with Node-Level Measures
              edges <- as.data.frame(igraph::as_edgelist(g, names=FALSE))
              nodes <- as.data.frame(sort(unique(c(edges$V1, edges$V2))))
              colnames(nodes) <- c('id')
              nodes$id <- nodes$id - 1
              
            # Create an alternate closeness function
              closeness <- function(g){ 
                geo <- 1/igraph::distances(g, mode='out')
                diag(geo) <- 0 # Define self-ties as 0
                apply(geo, 1, sum) # Return sum(1/geodist) for each vertex
              }
              
            # Reachablility function (Eliminate Loops, reaching yourself isn't that useful)
              reachable <- function(g){
                # Isolating the node's ego-network, the number of reachable nodes, and calculating 
                # the proportion of the total
                  proportion_reachable <- vector('numeric', nrow(nodes))
                  if(directed == TRUE){
                    for(i in seq_along(proportion_reachable)){
                      # Isolating connected vertices
                        ego_net <- igraph::subcomponent(g, v=igraph::V(g)[[i]], mode = c("out"))
                    
                      # Eliminating self-loops
                        ego_net <- ego_net[ego_net != igraph::V(g)[[i]]]
                    
                      # Calculating the proportion reachable
                        proportion_reachable[[i]] <- length(ego_net)/nrow(nodes)
                        rm(ego_net)
                    }
                  }else{
                    for(i in seq_along(proportion_reachable)){
                      # Isolating connected vertices
                        ego_net <- igraph::subcomponent(g, v=igraph::V(g)[[i]], mode = c("all"))
                    
                      # Eliminating self-loops
                        ego_net <- ego_net[ego_net != igraph::V(g)[[i]]]
                    
                      # Calculating the proportion reachable
                        proportion_reachable[[i]] <- length(ego_net)/nrow(nodes)
                        rm(ego_net)
                    }
                  }
                
                # Writing to global environment
                  assign(x = 'reachability', value = proportion_reachable,.GlobalEnv)  
              }
              
            # Adding Node-Level Measures
              total_degree <- igraph::degree(g, mode='all', loops=FALSE)
              weighted_degree <- igraph::strength(g, mode='all', loops=FALSE)
              in_degree <- igraph::degree(g, mode='in', loops=FALSE)
              out_degree <- igraph::degree(g, mode='out', loops=FALSE)
              closeness <- closeness(g)
              betweenness <- igraph::betweenness(g, directed=as.logical(directed))
              bonpow <- igraph::bonpow(g, loops=FALSE, exponent = 0.75)
              eigen_cen <- igraph::eigen_centrality(g, directed=as.logical(directed), scale=FALSE)$vector
              constraint <- igraph::constraint(g)
              reachability <- reachable(g)
              
              nodes <- as.data.frame(cbind(nodes, total_degree, weighted_degree, in_degree, out_degree, 
                                           closeness, betweenness, bonpow, eigen_cen, constraint, reachability))
          }
        }else if (package == 'network'){
          if(directed == TRUE){
            # Outputting a directed graph
              g <- network::as.network(adjacency_matrix, matrix.type = "adjacency", directed = TRUE)
            
            # Specifying network metric commands
              if (directed == TRUE) {
                gmode <- 'digraph'
                cmode <- 'directed'
              }else{
                gmode <- 'graph'
                cmode <- 'undirected'
              }
              
            # Extracting nodes
              edges <- network::as.edgelist(g)
              nodes <- as.data.frame(sort(unique(c(edges[,1], edges[,2]))))
              colnames(nodes) <- c('id')
              
            # Create an alternate closeness function
              closeness <- function(g){           # Create an alternate closeness function!
                geo <- 1/sna::geodist(g)$gdist    # Get the matrix of 1/geodesic distance
                diag(geo) <- 0                    # Define self-ties as 0
                apply(geo, 1, sum)                # Return sum(1/geodist) for each vertex
              }
              
            # Reachability function
              reachable <- function(g){
                # Calculating the proportion reacable for each node
                  proportion_reachable <- vector('numeric', nrow(nodes))
                  for(i in seq_along(proportion_reachable)){
                    # Getting all reachable pairs
                      reachable_edges <- as.data.frame(sna::reachability(g, return.as.edgelist = TRUE))
                  
                    # Isolating ego network
                      ego_net <- reachable_edges[(reachable_edges$V1 == nodes[i, 1]), ]
                  
                    # Elminating Self-Loops
                      ego_net <- ego_net[(ego_net$V1 != ego_net$V2), ]
                  
                    # Calculating the proportion reachable
                      proportion_reachable[[i]] <- nrow(ego_net)/nrow(nodes)
                      rm(reachable_edges, ego_net)
                  }
                
                # Writing to global environment
                  assign(x = 'reachability', value = proportion_reachable,.GlobalEnv)  
              }
              
            # Function calculating Burt's constraint measure
              constraint.orig <- function(g) {
                # Sub-setting Adjacency Matrix
                  idx <- sna::degree(g, diag=FALSE, gmode=gmode, cmode='freeman', ignore.eval=TRUE) != 0
                  A <- network::as.matrix.network.adjacency(g)
                  A <- A[idx, idx]
                  n <- sum(idx)
                
                # Calculating constraint meatures
                  one <- c(rep(1,n))
                  CZ <- A + t(A)
                  cs <- CZ %*% one                      # degree of vertices
                  ics <- 1/cs
                  CS <- ics %*% t(one)                  # 1/degree of vertices
                  P <- CZ * CS                          # intermediate result: proportionate tie strengths
                  PSQ <- P%*%P                          # sum paths of length two
                  P.bi <- as.numeric(P>0)               # exclude paths to non-contacts (& reflexive):
                  PC <- (P + (PSQ*P.bi))^2              # dyadic constraint
                  ci <- PC %*% one                      # overall constraint
                  dim(ci) <- NULL
                
                # Assigning scores to node ids
                  ci2 <- nodes$id
                  ci2[idx] <- ci
                  ci2[!idx] <- NaN
                
                # Assigning final scores to global environment
                  assign(x = 'constraint_score', value = ci2,.GlobalEnv)  
              }
            
            # Adding node-level measures
              total_degree <- sna::degree(g, gmode=gmode, cmode='freeman')
              weighted_degree <- sna::degree(g, gmode=gmode, cmode='freeman', ignore.eval=FALSE)
              in_degree <- sna::degree(g, gmode=gmode, cmode='indegree')
              out_degree <- sna::degree(g, gmode=gmode, cmode='outdegree')
              closeness <- closeness(g)
              betweenness <- sna::betweenness(g, gmode=gmode, cmode=cmode)
              bonpow <- as.numeric(sna::bonpow(g, gmode=gmode, exponent = 0.75))
              eigen_cen <- sna::evcent(g, gmode=gmode, rescale=FALSE)
              constraint <- constraint.orig(g)
              reachability <- reachable(g)
              
              nodes <- as.data.frame(cbind(nodes, total_degree, weighted_degree, in_degree, out_degree, 
                                           closeness, betweenness, bonpow, eigen_cen, constraint, reachability))
          }else{
            # Outputting undirected graph
              g <- network::as.network(adjacency_matrix, matrix.type = "adjacency", directed = FALSE)
            
            # Specifying network metric commands
              if (directed == TRUE) {
                gmode <- 'digraph'
                cmode <- 'directed'
              }else{
                gmode <- 'graph'
                cmode <- 'undirected'
              }
              
            # Extracting nodes
              edges <- network::as.edgelist(g)
              nodes <- as.data.frame(sort(unique(c(edges[,1], edges[,2]))))
              colnames(nodes) <- c('id')
              
            # Create an alternate closeness function
              closeness <- function(g){           # Create an alternate closeness function!
                geo <- 1/sna::geodist(g)$gdist    # Get the matrix of 1/geodesic distance
                diag(geo) <- 0                    # Define self-ties as 0
                apply(geo, 1, sum)                # Return sum(1/geodist) for each vertex
              }
              
            # Reachability function
              reachable <- function(g){
                # Calculating the proportion reacable for each node
                  proportion_reachable <- vector('numeric', nrow(nodes))
                  for(i in seq_along(proportion_reachable)){
                    # Getting all reachable pairs
                      reachable_edges <- as.data.frame(sna::reachability(g, return.as.edgelist = TRUE))
                  
                    # Isolating ego network
                      ego_net <- reachable_edges[(reachable_edges$V1 == nodes[i, 1]), ]
                  
                    # Elminating Self-Loops
                      ego_net <- ego_net[(ego_net$V1 != ego_net$V2), ]
                  
                    # Calculating the proportion reachable
                      proportion_reachable[[i]] <- nrow(ego_net)/nrow(nodes)
                      rm(reachable_edges, ego_net)
                  }
                
                # Writing to global environment
                  assign(x = 'reachability', value = proportion_reachable,.GlobalEnv)  
              }
              
            # Function calculating Burt's constraint measure
              constraint.orig <- function(g) {
                # Sub-setting Adjacency Matrix
                  idx <- sna::degree(g, diag=FALSE, gmode=gmode, cmode='freeman', ignore.eval=TRUE) != 0
                  A <- network::as.matrix.network.adjacency(g)
                  A <- A[idx, idx]
                  n <- sum(idx)
                
                # Calculating constraint meatures
                  one <- c(rep(1,n))
                  CZ <- A + t(A)
                  cs <- CZ %*% one                      # degree of vertices
                  ics <- 1/cs
                  CS <- ics %*% t(one)                  # 1/degree of vertices
                  P <- CZ * CS                          # intermediate result: proportionate tie strengths
                  PSQ <- P%*%P                          # sum paths of length two
                  P.bi <- as.numeric(P>0)               # exclude paths to non-contacts (& reflexive):
                  PC <- (P + (PSQ*P.bi))^2              # dyadic constraint
                  ci <- PC %*% one                      # overall constraint
                  dim(ci) <- NULL
                
                # Assigning scores to node ids
                  ci2 <- nodes$id
                  ci2[idx] <- ci
                  ci2[!idx] <- NaN
                
                # Assigning final scores to global environment
                  assign(x = 'constraint_score', value = ci2,.GlobalEnv)  
              }
              
            # Adding node-level measures
              total_degree <- sna::degree(g, gmode=gmode, cmode='freeman')
              weighted_degree <- sna::degree(g, gmode=gmode, cmode='freeman', ignore.eval=FALSE)
              in_degree <- sna::degree(g, gmode=gmode, cmode='indegree')
              out_degree <- sna::degree(g, gmode=gmode, cmode='outdegree')
              closeness <- closeness(g)
              betweenness <- sna::betweenness(g, gmode=gmode, cmode=cmode)
              bonpow <- as.numeric(sna::bonpow(g, gmode=gmode, exponent = 0.75))
              eigen_cen <- sna::evcent(g, gmode=gmode, rescale=FALSE)
              constraint <- constraint.orig(g)
              reachability <- reachable(g)
              
              nodes <- as.data.frame(cbind(nodes, total_degree, weighted_degree, in_degree, out_degree, 
                                           closeness, betweenness, bonpow, eigen_cen, constraint, reachability))
          }
        }else{
          print('Network package not supported.')
        }
      
      # Outputting Network Object to the Global Environment
        assign(x = net_name, value = g,.GlobalEnv)
        assign(x = 'nodes', value = nodes, .GlobalEnv)
    }else if(data_type == 'adjacency_list'){
      # Is the adjacency list a list
        if(class(adjacency_list) == 'list'){
          g <- igraph::graph_from_adj_list(adj_list, mode="out")
        }else{
          # Converting to a list
            adj_list <- vector('list', dim(adjacency_list)[[1]])
            names(adj_list) <- as.character(adjacency_list[,1])
            for(i in seq_along(adj_list)){
              adj_row <- unique(as.integer(strsplit(adjacency_list[i,2], ' ')[[1]]))
              adj_list[[i]] <- vector('list', length(adj_row))
              for(j in seq_along(adj_row)) {
                adj_list[[i]][[j]] <- adj_row[[j]]
              }
              rm(adj_row)
            }
          
          # Generating network from adjacency list
            g <- igraph::graph_from_adj_list(adj_list, mode="out")
        }
      
      # Generating network object
        if (package == 'igraph') {
          # Copying igraph object
            g <- g
          
          # Creating Nodes File with Node-Level Measures
            edges <- as.data.frame(igraph::as_edgelist(g, names=FALSE))
            nodes <- as.data.frame(sort(unique(c(edges$V1, edges$V2))))
            colnames(nodes) <- c('id')
            nodes$id <- nodes$id - 1
            
          # Create an alternate closeness function
            closeness <- function(g){ 
              geo <- 1/igraph::distances(g, mode='out')
              diag(geo) <- 0                            # Define self-ties as 0
              apply(geo, 1, sum)                        # Return sum(1/geodist) for each vertex
            }
            
          # Reachablility function (Eliminate Loops, reaching yourself isn't that useful)
            reachable <- function(g){
              # Isolating the node's ego-network, the number of reachable nodes, and calculating 
              # the proportion of the total
                proportion_reachable <- vector('numeric', nrow(nodes))
                if(directed == TRUE){
                  for(i in seq_along(proportion_reachable)){
                    # Isolating connected vertices
                      ego_net <- igraph::subcomponent(g, v=igraph::V(g)[[i]], mode = c("out"))
                  
                    # Eliminating self-loops
                      ego_net <- ego_net[ego_net != igraph::V(g)[[i]]]
                  
                    # Calculating the proportion reachable
                      proportion_reachable[[i]] <- length(ego_net)/nrow(nodes)
                      rm(ego_net)
                  }
                }else{
                for(i in seq_along(proportion_reachable)){
                  # Isolating connected vertices
                    ego_net <- igraph::subcomponent(g, v=igraph::V(g)[[i]], mode = c("all"))
                  
                  # Eliminating self-loops
                    ego_net <- ego_net[ego_net != igraph::V(g)[[i]]]
                  
                  # Calculating the proportion reachable
                    proportion_reachable[[i]] <- length(ego_net)/nrow(nodes)
                    rm(ego_net)
                }
              }
              
              # Writing to global environment
                assign(x = 'reachability', value = proportion_reachable,.GlobalEnv)  
            }
            
          # Adding Node-Level Measures
            total_degree <- igraph::degree(g, mode='all', loops=FALSE)
            weighted_degree <- igraph::strength(g, mode='all', loops=FALSE)
            in_degree <- igraph::degree(g, mode='in', loops=FALSE)
            out_degree <- igraph::degree(g, mode='out', loops=FALSE)
            closeness <- closeness(g)
            betweenness <- igraph::betweenness(g, directed=as.logical(directed))
            bonpow <- igraph::bonpow(g, loops=FALSE, exponent = 0.75)
            eigen_cen <- igraph::eigen_centrality(g, directed=as.logical(directed), scale=FALSE)$vector
            constraint <- igraph::constraint(g)
            reachability <- reachable(g)
            
            nodes <- as.data.frame(cbind(nodes, total_degree, weighted_degree, in_degree, out_degree, 
                                         closeness, betweenness, bonpow, eigen_cen, constraint, reachability))
        }else if (package == 'network') {
          # Getting Edgelist: iGraph
            edges <- as.data.frame(igraph::as_edgelist(g, names=FALSE))
            colnames(edges) <- c('i_id', 'j_id')
          
          # Checking if there are edge values
            if (length(igraph::get.edge.attribute(g)) > 0) {
              edge_values <- as.data.frame(igraph::get.edge.attribute(g))
              edges <- cbind(edges, edge_values)
              rm(edge_values)
            }else{
              edges$weight <- 1
            }
          
          # Extracting nodelist
            adj_ids <- igraph::get.adjlist(g, mode='all')
            nodes <- as.data.frame(seq(1, length(adj_ids), 1))
            colnames(nodes)[[1]] <- c('id')
            rm(adj_ids)
            
          # Generating network data object
            g <- network::network.initialize(nrow(nodes), directed = as.logical(directed))
            
            el <- edges[,c(1,2)]
            el[,1] <- as.character(el[,1])
            el[,2] <- as.character(el[,2])
            g <- network::add.edges(g, el[,1], el[,2])
            
          # Adding Node-Level Measures
            if (directed == TRUE) {
              gmode <- 'digraph'
              cmode <- 'directed'
            }else{
              gmode <- 'graph'
              cmode <- 'undirected'
            }
            
          # Create an alternate closeness function
            closeness <- function(g){           # Create an alternate closeness function!
              geo <- 1/sna::geodist(g)$gdist    # Get the matrix of 1/geodesic distance
              diag(geo) <- 0                    # Define self-ties as 0
              apply(geo, 1, sum)                # Return sum(1/geodist) for each vertex
            }
            
          # Reachability function
            reachable <- function(g){
              # Calculating the proportion reacable for each node
                proportion_reachable <- vector('numeric', nrow(nodes))
                for(i in seq_along(proportion_reachable)){
                  # Getting all reachable pairs
                    reachable_edges <- as.data.frame(sna::reachability(g, return.as.edgelist = TRUE))
                
                  # Isolating ego network
                    ego_net <- reachable_edges[(reachable_edges$V1 == nodes[i, 1]), ]
                
                  # Elminating Self-Loops
                    ego_net <- ego_net[(ego_net$V1 != ego_net$V2), ]
                
                # Calculating the proportion reachable
                    proportion_reachable[[i]] <- nrow(ego_net)/nrow(nodes)
                    rm(reachable_edges, ego_net)
              }
              
              # Writing to global environment
                assign(x = 'reachability', value = proportion_reachable,.GlobalEnv)  
            }
            
          # Function calculating Burt's constraint measure
            constraint.orig <- function(g) {
              # Sub-setting Adjacency Matrix
                idx <- sna::degree(g, diag=FALSE, gmode=gmode, cmode='freeman', ignore.eval=TRUE) != 0
                A <- network::as.matrix.network.adjacency(g)
                A <- A[idx, idx]
                n <- sum(idx)
              
              # Calculating constraint meatures
                one <- c(rep(1,n))
                CZ <- A + t(A)
                cs <- CZ %*% one                      # degree of vertices
                ics <- 1/cs
                CS <- ics %*% t(one)                  # 1/degree of vertices
                P <- CZ * CS                          # intermediate result: proportionate tie strengths
                PSQ <- P%*%P                          # sum paths of length two
                P.bi <- as.numeric(P>0)               # exclude paths to non-contacts (& reflexive):
                PC <- (P + (PSQ*P.bi))^2              # dyadic constraint
                ci <- PC %*% one                      # overall constraint
                dim(ci) <- NULL
              
              # Assigning scores to node ids
                ci2 <- nodes$id
                ci2[idx] <- ci
                ci2[!idx] <- NaN
              
              # Assigning final scores to global environment
                assign(x = 'constraint_score', value = ci2,.GlobalEnv)  
            }
            
            total_degree <- sna::degree(g, gmode=gmode, cmode='freeman')
            weighted_degree <- sna::degree(g, gmode=gmode, cmode='freeman', ignore.eval=FALSE)
            in_degree <- sna::degree(g, gmode=gmode, cmode='indegree')
            out_degree <- sna::degree(g, gmode=gmode, cmode='outdegree')
            closeness <- closeness(g)
            betweenness <- sna::betweenness(g, gmode=gmode, cmode=cmode)
            bonpow <- as.numeric(sna::bonpow(g, gmode=gmode, exponent = 0.75))
            eigen_cen <- sna::evcent(g, gmode=gmode, rescale=FALSE)
            constraint <- constraint.orig(g)
            reachability <- reachable(g)
            
            nodes <- as.data.frame(cbind(nodes, total_degree, weighted_degree, in_degree, out_degree, 
                                         closeness, betweenness, bonpow, eigen_cen, constraint, reachability))
        }else {
          print('Network package not supported.')
        }
        
      # Outputting network object to global environment
        assign(x = net_name, value = g,.GlobalEnv)
        assign(x = 'nodes', value = nodes, .GlobalEnv)
    }else{
      # Creating Canonical Node and Edgelists
        if(weights==FALSE){
          edgelist <-as.matrix(cbind(i_elements, j_elements))
          edgelist <-cbind(edgelist, rep(1,nrow(edgelist)))
          colnames(edgelist)[[3]] <- c('weight')
        }else{
          edgelist <-as.matrix(cbind(i_elements, j_elements, weights))
        }
      
        edgelist <- edgelist[!(rowSums(is.na(edgelist))), ]
        edgelist <- edgelist[edgelist[,1] != missing_code & edgelist[,2] != missing_code, ] 
        edgelist <- cbind(seq(1,nrow(edgelist), 1), edgelist)
        colnames(edgelist)[[1]] <- c('Obs_ID')
        
      # Adding Nodes
        if(nodelist==FALSE) {
          nodes <- as.data.frame(sort(unique(c(edgelist[,2], edgelist[,3]))))
          nodes <- cbind(seq(1,nrow(nodes),1), nodes)
          colnames(nodes) <- c('id', 'label')
          
          senders <- as.data.frame(edgelist[,c(1:2)])
          colnames(senders)[[2]] <- c('label')
          senders <- dplyr::left_join(senders, nodes, by='label')
          colnames(senders)[c(2,3)] <- c('i_elements', 'i_id')
          
          targets <- as.data.frame(edgelist[,c(1,3,4)])
          colnames(targets)[[2]] <- c('label')
          targets <- dplyr::left_join(targets, nodes, by='label')
          colnames(targets)[c(2,4)] <- c('j_elements', 'j_id')
          targets <- targets[c(1,2,4,3)]
          
          edgelist <- dplyr::left_join(senders, targets, by='Obs_ID')
          edgelist <- edgelist[order(edgelist$i_id, edgelist$j_id), ]
          edgelist <- as.matrix(edgelist)
          rm(senders, targets)
        }else{
          nodes <- nodelist[,]
          
          nodes <- cbind(seq(1,nrow(nodes),1), nodes)
          colnames(nodes) <- c('id', 'label')
          
          senders <- as.data.frame(edgelist[,c(1:2)])
          colnames(senders)[[2]] <- c('label')
          senders <- dplyr::left_join(senders, nodes, by='label')
          colnames(senders)[c(2,3)] <- c('i_elements', 'i_id')
          
          targets <- as.data.frame(edgelist[,c(1,3,4)])
          colnames(targets)[[2]] <- c('label')
          targets <- dplyr::left_join(targets, nodes, by='label')
          colnames(targets)[c(2,4)] <- c('j_elements', 'j_id')
          targets <- targets[c(1,2,4,3)]
          
          edgelist <- dplyr::left_join(senders, targets, by='Obs_ID')
          edgelist <- edgelist[order(edgelist$i_id, edgelist$j_id), ]
          edgelist <- as.matrix(edgelist)
          rm(senders, targets)
        }
        
      # Create Graph Objects
        if(package == 'igraph'){
          # Make Zero-Indexed
            nodes$id <- nodes$id - 1
            edgelist[,3] <- edgelist[,3] - 1
            edgelist[,5] <- edgelist[,5] - 1
            
          # Make Weights Reflect Frequency Rather than Distance
            if(weight_type == 'frequency') {
              edgelist[,6] <- 1/edgelist[,6]
            }else{
              edgelist[,6] <- edgelist[,6]
            }
            
          # Creating igraph object
            colnames(nodes)[[2]] <- c('attr')
            g <- igraph::graph_from_data_frame(d = edgelist[,c(3,5)], directed = as.logical(directed), vertices = nodes) 
            
          # Adding edge weights
            igraph::edge.attributes(g)$weight <- edgelist[,6]
            
          # Create an alternate closeness function
            closeness <- function(g){ 
              geo <- 1/igraph::distances(g, mode='out')
              diag(geo) <- 0 # Define self-ties as 0
              apply(geo, 1, sum) # Return sum(1/geodist) for each vertex
            }
            
          # Reachablility function (Eliminate Loops, reaching yourself isn't that useful)
            reachable <- function(g){
              # Isolating the node's ego-network, the number of reachable nodes, and calculating 
              # the proportion of the total
                proportion_reachable <- vector('numeric', nrow(nodes))
                if(directed == TRUE){
                  for(i in seq_along(proportion_reachable)){
                    # Isolating connected vertices
                      ego_net <- igraph::subcomponent(g, v=igraph::V(g)[[i]], mode = c("out"))
                      
                    # Eliminating self-loops
                      ego_net <- ego_net[ego_net != igraph::V(g)[[i]]]
                      
                    # Calculating the proportion reachable
                      proportion_reachable[[i]] <- length(ego_net)/nrow(nodes)
                      rm(ego_net)
                  }
                }else{
                  for(i in seq_along(proportion_reachable)){
                    # Isolating connected vertices
                      ego_net <- igraph::subcomponent(g, v=igraph::V(g)[[i]], mode = c("all"))
                    
                    # Eliminating self-loops
                      ego_net <- ego_net[ego_net != igraph::V(g)[[i]]]
                    
                    # Calculating the proportion reachable
                      proportion_reachable[[i]] <- length(ego_net)/nrow(nodes)
                      rm(ego_net)
                  }
                }
                
              # Writing to global environment
                assign(x = 'reachability', value = proportion_reachable,.GlobalEnv)  
            }
            
          # Adding Node-Level Measures
            total_degree <- igraph::degree(g, mode='all', loops=FALSE)
            weighted_degree <- igraph::strength(g, mode='all', loops=FALSE)
            in_degree <- igraph::degree(g, mode='in', loops=FALSE)
            out_degree <- igraph::degree(g, mode='out', loops=FALSE)
            closeness <- closeness(g)
            betweenness <- igraph::betweenness(g, directed=as.logical(directed))
            bonpow <- igraph::bonpow(g, loops=FALSE, exponent = 0.75)
            eigen_cen <- igraph::eigen_centrality(g, directed=as.logical(directed), scale=FALSE)$vector
            constraint <- igraph::constraint(g)
            reachability <- reachable(g)
                          
            nodes <- as.data.frame(cbind(nodes, total_degree, weighted_degree, in_degree, out_degree, 
                                         closeness, betweenness, bonpow, eigen_cen, constraint, reachability))
            
        }else if(package == 'network'){
          # Make Weights Reflect Distance Rather than Frequency
            if(weight_type != 'frequency') {
              edgelist[,6] <- 1/edgelist[,6]
            }else{
              edgelist[,6] <- edgelist[,6]
            }
          
          # Creating sna networks to isolate network components
            g <- network::network.initialize(nrow(nodes), directed = as.logical(directed))
          
          # Adding Edges
            el <- edgelist[,c(3,5)]
            el[,1] <- as.character(el[,1])
            el[,2] <- as.character(el[,2])
            g <- network::add.edges(g, el[,1], el[,2])
          
          # Adding Weights
            network::set.edge.value(g,"weight", edgelist[,6])
            
          # Adding Node-Level Measures
            if (directed == TRUE) {
              gmode <- 'digraph'
              cmode <- 'directed'
            }else{
              gmode <- 'graph'
              cmode <- 'undirected'
            }
            
          # Create an alternate closeness function
            closeness <- function(g){           # Create an alternate closeness function!
              geo <- 1/sna::geodist(g)$gdist    # Get the matrix of 1/geodesic distance
              diag(geo) <- 0                    # Define self-ties as 0
              apply(geo, 1, sum)                # Return sum(1/geodist) for each vertex
            }
            
          # Reachability function
            reachable <- function(g){
              # Calculating the proportion reacable for each node
                proportion_reachable <- vector('numeric', nrow(nodes))
                for(i in seq_along(proportion_reachable)){
                  # Getting all reachable pairs
                    reachable_edges <- as.data.frame(sna::reachability(g, return.as.edgelist = TRUE))
                  
                  # Isolating ego network
                    ego_net <- reachable_edges[(reachable_edges$V1 == nodes[i, 1]), ]
                  
                  # Elminating Self-Loops
                    ego_net <- ego_net[(ego_net$V1 != ego_net$V2), ]
                  
                  # Calculating the proportion reachable
                    proportion_reachable[[i]] <- nrow(ego_net)/nrow(nodes)
                    rm(reachable_edges, ego_net)
                }
                
              # Writing to global environment
                assign(x = 'reachability', value = proportion_reachable,.GlobalEnv)  
            }
            
          # Function calculating Burt's constraint measure
            constraint.orig <- function(g) {
              # Sub-setting Adjacency Matrix
                idx <- sna::degree(g, diag=FALSE, gmode=gmode, cmode='freeman', ignore.eval=TRUE) != 0
                A <- network::as.matrix.network.adjacency(g)
                A <- A[idx, idx]
                n <- sum(idx)
              
              # Calculating constraint meatures
                one <- c(rep(1,n))
                CZ <- A + t(A)
                cs <- CZ %*% one                      # degree of vertices
                ics <- 1/cs
                CS <- ics %*% t(one)                  # 1/degree of vertices
                P <- CZ * CS                          # intermediate result: proportionate tie strengths
                PSQ <- P%*%P                          # sum paths of length two
                P.bi <- as.numeric(P>0)               # exclude paths to non-contacts (& reflexive):
                PC <- (P + (PSQ*P.bi))^2              # dyadic constraint
                ci <- PC %*% one                      # overall constraint
                dim(ci) <- NULL
              
              # Assigning scores to node ids
                ci2 <- nodes$id
                ci2[idx] <- ci
                ci2[!idx] <- NaN
              
              # Assigning final scores to global environment
                assign(x = 'constraint_score', value = ci2,.GlobalEnv)  
            }
            
            total_degree <- sna::degree(g, gmode=gmode, cmode='freeman', ignore.eval=TRUE)
            weighted_degree <- sna::degree(g, gmode=gmode, cmode='freeman', ignore.eval=FALSE)
            in_degree <- sna::degree(g, gmode=gmode, cmode='indegree')
            out_degree <- sna::degree(g, gmode=gmode, cmode='outdegree')
            closeness <- closeness(g)
            betweenness <- sna::betweenness(g, gmode=gmode, cmode=cmode)
            bonpow <- as.numeric(sna::bonpow(g, gmode=gmode, exponent = 0.75))
            eigen_cen <- sna::evcent(g, gmode=gmode, rescale=FALSE)
            constraint <- constraint.orig(g)
            reachability <- reachable(g)
            
            nodes <- as.data.frame(cbind(nodes, total_degree, weighted_degree, in_degree, out_degree, 
                                         closeness, betweenness, bonpow, eigen_cen, constraint,reachability))
        }else{
          edgelist <- edgelist[,]
        }
        
      # Outputting Network Objects
        assign(x = 'edgelist', value = edgelist,.GlobalEnv)  
        assign(x = 'nodelist', value = nodes,.GlobalEnv)  
        assign(x = net_name, value = g,.GlobalEnv)
    }
  }
    
# Edgelist Example
  netwrite(data_type = c('edgelist'), adjacency_matrix=FALSE, adjacency_list=FALSE,
           nodelist=FALSE, i_elements=community_2$ego_nid, j_elements=community_2$alter_id, weights=FALSE,
           package='igraph', missing_code=99999, weight_type='frequency', 
           directed='TRUE', net_name='net_1')
  
  plot(net_1)
  
  netwrite(data_type = c('edgelist'), adjacency_matrix=FALSE, adjacency_list=FALSE,
           nodelist=FALSE, i_elements=community_2$ego_nid, j_elements=community_2$alter_id, weights=FALSE,
           package='network', missing_code=99999, weight_type='frequency', 
           directed='TRUE', net_name='net_2')
  
  plot(net_2)

# Adjacency Matrix Example
  adj_mat <- as.matrix(net_2, matrix.type="adjacency")
  
  netwrite(data_type = c('adjacency_matrix'), adjacency_matrix=adj_mat, adjacency_list=FALSE,
           nodelist=FALSE, i_elements=FALSE, j_elements=FALSE, weights=FALSE,
           package='igraph', missing_code=99999, weight_type='frequency', 
           directed='TRUE', net_name='net_3')
  
  plot(net_3)
  
  netwrite(data_type = c('adjacency_matrix'), adjacency_matrix=adj_mat, adjacency_list=FALSE,
           nodelist=FALSE, i_elements=FALSE, j_elements=FALSE, weights=FALSE,
           package='network', missing_code=99999, weight_type='frequency', 
           directed='TRUE', net_name='net_4')
  
  plot(net_4)
  
# Adjacency List Example
  adjacency_list <- igraph::as_adj_list(net_1, mode='out')
  
  adj_list <- vector('list', length(adjacency_list))
  for (i in seq_along(adjacency_list)) {
    adj_row <- unique(as.integer(adjacency_list[[i]]))
    adj_row <- paste(adj_row, collapse = ' ')
    adj_list[[i]] <- adj_row
    rm(adj_row)
  }
  
  adj_list <- as.data.frame(do.call("rbind", adj_list))
  adj_list <- cbind(names(adjacency_list), adj_list)
  colnames(adj_list) <- c('ego', 'alters')
  
  netwrite(data_type = c('adjacency_list'), adjacency_matrix=FALSE, adjacency_list=adj_list,
           nodelist=FALSE, i_elements=FALSE, j_elements=FALSE, weights=FALSE,
           package='network', missing_code=99999, weight_type='frequency', 
           directed='TRUE', net_name='net_5')
  
  plot(net_5)
  
  netwrite(data_type = c('adjacency_list'), adjacency_matrix=FALSE, adjacency_list=adj_list,
           nodelist=FALSE, i_elements=FALSE, j_elements=FALSE, weights=FALSE,
           package='igraph', missing_code=99999, weight_type='frequency', 
           directed='TRUE', net_name='net_6')
  
  plot(net_6)
  
###############
#   netread   #
###############

netread <- function(package="network", network_object=network) {
  # Network Control Logic
    if(package == "network"){
      # Getting Edgelist
        edges <- as.data.frame(network::as.edgelist(network_object))
        colnames(edges) <- c('i_id', 'j_id')
        
      # Checking if there are edge values
        if(length(network::list.edge.attributes(network_object)[network::list.edge.attributes(network_object) != "na"]) >= 1){
          edge_attribute <- network::list.edge.attributes(network_object)[network::list.edge.attributes(network_object) != "na"]
          edge_value <- network::get.edge.value(network_object, edge_attribute, unlist = TRUE, na.omit = TRUE, null.na = FALSE, deleted.edges.omit = TRUE)
          edges$weight <- edge_value
        }else{
          edges$weight <- 1
        }
        
      # Extracting Nodelist 
        nodes <- network::get.vertex.attribute(network_object, "vertex.names")
        nodes <- as.data.frame(cbind(seq(1, length(nodes), 1), nodes))
        colnames(nodes) <- c('id', 'label')
        rm(edge_value)
    }else if (package == 'igraph'){
      # Getting Edgelist: iGraph
        edges <- as.data.frame(igraph::as_edgelist(network_object, names=FALSE))
        colnames(edges) <- c('i_id', 'j_id')
        
      # Checking if there are edge values
        if (length(igraph::get.edge.attribute(network_object)) > 0) {
         edge_values <- as.data.frame(igraph::get.edge.attribute(network_object))
         edges <- cbind(edges, edge_values)
        }else{
          edges$weight <- 1
        }
        
      # Extracting nodelist
        nodes <- as.data.frame(igraph::get.vertex.attribute(network_object))
        colnames(nodes)[[1]] <- c('id')
        nodes$id <- as.numeric(nodes$id)
        nodes$id <- nodes$id + 1
        rm(edge_values)
    } else {
      network_object <- network_object
      print('Package Not Supported')
    }
  
    # Outputting Network Objects
      assign(x = 'edges', value = edges,.GlobalEnv)  
      assign(x = 'nodes', value = nodes,.GlobalEnv)  
}

netread(package='network', network_object=network)

#############
#   NOTES   #
#############

# Calculating Flow Hierarchy (http://web.mit.edu/~cmagee/www/documents/28-DetectingEvolvingPatterns_FlowHierarchy.pdf)
  flow_hierarchy <- function(g){
    # Notes: Luo and Magee's algorithm computes the flow hierarchy through exponentiation of the adjacency matrix.  This function implements an
    # An alternative approach is to  find all the strongly connected components.
    # An edge is in a cycle if and only if it is in a strongly connected component
    
    if(igraph::is.directed(g) == TRUE){
      # Generate a sorted list of strongly connected components
        scc <- igraph::components(g, mode='strong')
        scc <- as.data.frame(cbind(seq(1, length(igraph::V(g)), 1), as.integer(scc[[1]])))
        colnames(scc) <- c('node_id', 'component_id')

      # Assigning vertex ids and component ids 
        g <- igraph::set_vertex_attr(g, "components", index = igraph::V(g), as.factor(scc$component_id ))
        g <- igraph::set.vertex.attribute(g,'name',index=igraph::V(g),as.character(1:igraph::vcount(g)))
        
      # Calculating the node weights for each node for each component 
      # Node weights are the weighted degree of each node
        components <- sort(unique(scc$component_id))
        weights <- vector('list', length(components))
        names(weights) <- components
        for(i in seq_along(components)){
          c <- components[[i]]
          sub_ids <- sort(scc[(scc$component_id == c), ][[1]]) 
          g.sub <- igraph::induced.subgraph(graph=g, vids=sub_ids)
          sub_weights <- igraph::strength(g.sub, vids=igraph::V(g.sub), mode='all')
          sub_ids <- as.integer(igraph::get.vertex.attribute(g.sub, 'name'))
          c_weights <- as.data.frame(cbind(sub_ids, sub_weights))
          colnames(c_weights) <- c('node_id', 'node_weight')
          weights[[i]] <- c_weights
          rm(c, g.sub, sub_weights, sub_ids )
        }
        
        weights <- do.call("rbind", weights)
        scc <- dplyr::left_join(scc, weights, by='node_id')
        rm(weights)
          
      # Calculating the weighted degree for the full graph
        scc$graph_weight <- igraph::strength(g, vids=igraph::V(g), mode='all')
        
      # Calculating flow hierarchy
        flow_hierarchy_score <- 1 - (sum(scc$node_weight)/sum(scc$graph_weight))
        
      # Assigning Score to the Global Environment 
        assign(x = 'flow_hierarchy_score', value = flow_hierarchy_score,.GlobalEnv)  
    }else{
      print("The graph being analyzed must be a digraph to compute a flow hierarchy score")
    }
  }
  
# Add Health Example
  flow_hierarchy(net_1)
  
# A Star
  star <- igraph::make_star(40)
  plot(star)
  
  flow_hierarchy(star)
  
# Florentine Families (Undirected Graph)
  library(netrankr)
  data("florentine_m")
  flo <- igraph::delete_vertices(florentine_m,which(igraph::degree(florentine_m)==0))
  plot(flo)
  
  flow_hierarchy(flo)
  
# Community 2
  community_2 <- communities_edgelist[[2]]
  
  netwrite(data_type = c('edgelist'), adjacency_matrix=FALSE, adjacency_list=FALSE,
           nodelist=FALSE, i_elements=community_2$ego_nid, j_elements=community_2$alter_id, weights=FALSE,
           package='igraph', missing_code=99999, weight_type='frequency', 
           directed='TRUE', net_name='net_1')
  
  plot(net_2)
  
# Network Diagnostics (Two pane figure displaying system and node-level measures)
  
# Burt's constraint score based on egonet implementation
  constraint <- function(g) {
    # Creating output vector for constraint scores
      constraint_scores <- vector('numeric', nrow(nodes))
    
    # Calculating each node's constraint score
      for(i in seq_along(constraint_scores)){
        # Isolating ego-network
          dati <- (sna::ego.extract(g, ego = nodes[i, 1], neighborhood = c("combined")))[[1]]
      
        # Calculating ego's constraint
          idego <- which(rownames(dati)==as.integer(nodes[i, 1]))
          n <- dim(dati)[1]
          S <- rep(0,n)
          for( j in 1:n)  for( y in setdiff(1:n,j)) S[j] <- S[j] + (dati[j,y] + dati[y,j])
      
          Pij <- dati
          Pij[,] <- NA
          for(j in 1:n ){
            for(k in setdiff(1:n,j) ){
              Pij[j,k] <- (dati[j,k] + dati[k,j])/ S[j]
            }
          }
      
          pp <- rep(0,n)
          for (j in setdiff(1:n,idego) )
            for (q in setdiff(1:n,c(idego,j) ) )
              pp[j] <- pp[j] + Pij[idego,q]*Pij[q,j]
              constraint_scores[[i]] <- sum((Pij[idego,] + pp)^2,na.rm=T)
        }
  }
  
# Burt's constraint score based on iGraph implementation: https://github.com/igraph/rigraph/blob/dev/R/structural.properties.R
  constraint.orig <- function(g) {
      # Subsetting Adjacency Matrix
        idx <- sna::degree(g, diag=FALSE, gmode=gmode, cmode='freeman', ignore.eval=TRUE) != 0
        A <- network::as.matrix.network.adjacency(g)
        A <- A[idx, idx]
        n <- sum(idx)
        
      # Calculating constraint meatures
        one <- c(rep(1,n))
        CZ <- A + t(A)
        cs <- CZ %*% one                      # degree of vertices
        ics <- 1/cs
        CS <- ics %*% t(one)                  # 1/degree of vertices
        P <- CZ * CS                          # intermediate result: proportionate tie strengths
        PSQ <- P%*%P                          # sum paths of length two
        P.bi <- as.numeric(P>0)               # exclude paths to non-contacts (& reflexive):
        PC <- (P + (PSQ*P.bi))^2              # dyadic constraint
        ci <- PC %*% one                      # overall constraint
        dim(ci) <- NULL
  
      # Assigning scores to node ids
        ci2 <- nodes$id
        ci2[idx] <- ci
        ci2[!idx] <- NaN
      
      # Assigning final scores to global environment
        assign(x = 'constraint_score', value = ci2,.GlobalEnv)  
  }
  
  n_constraint <- constraint.orig(g)



