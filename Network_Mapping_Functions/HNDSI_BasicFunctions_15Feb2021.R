# HNDSI Basic Network Function Prototypes
# Jonathan H. Morgan
# 15 February 2021

# Basic Functions: More Functions to Be Added
#   netread
#   netwrite

#########################
#   GENERAL FUNCTIONS   #
#########################

#Options
options(stringsAsFactors = FALSE)
options(mc.cores = parallel::detectCores())

###############################
#   EXAMPLE CASE: AHS_WPVAR   #
###############################

setwd('/Users/jonathan.h.morgan/Desktop')
import_data <- function(file_csv) {
  
  # Installing Necessary Packages 
    list.of.packages <- c('readr')
    new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
    if(length(new.packages)) install.packages(new.packages)
    rm(list.of.packages, new.packages)
    
  # Reading-In CSV with readr
    file_csv <- paste0(file_csv, '.csv')
    base_data <- readr::read_csv(file_csv, col_names = TRUE)
    
  # Creating Stacked Edgelist
    communities <- vector('list', length(unique(base_data$commcnt)))
    community_ids <- sort(unique(base_data$commcnt))
    names(communities) <- community_ids
    
    for (i in seq_along(communities)) {
      community <- base_data[base_data$commcnt == community_ids[[i]], ]
      egos <- sort(unique(community$ego_nid))
      
      alters <- vector('list', length(egos))
      names(alters) <- egos
      
      for (j in seq_along(egos)) {
        ego <- community[community$ego_nid == egos[[j]], ]
        m_friends <- as.data.frame(as.integer(ego[,c(4:8)]))
        m_friends <- cbind('Male', m_friends)
        colnames(m_friends) <- c('gender','alter_id')
        
        f_friends <- as.data.frame(as.integer(ego[,c(14:18)]))
        f_friends <- cbind('Female', f_friends)
        colnames(f_friends) <- c('gender','alter_id')
        
        alter_net <- rbind(m_friends, f_friends)
        alter_net <- cbind(egos[[j]], alter_net)
        alter_net <- cbind(community_ids[[i]], alter_net)
        colnames(alter_net)[c(1:2)] <- c('commcnt', 'ego_nid')
        
        alters[[j]] <- alter_net
        
        rm(alter_net, ego, m_friends, f_friends)
      }
      
      communities[[i]] <- do.call("rbind", alters)
      
      rm(community, egos, alters)
    }
  
  # Assigning communities edglist to the Global Environment
    assign(x = 'communities_edgelist', value = communities,.GlobalEnv)  
    
  return(base_data)
}

base_data <- import_data('ahs_wpvar')

# Focusing on Community One for Demonstration Purposes
  community_1 <- communities_edgelist[[1]]

################
#   netwrite   #
################
  
# Notes:
#   nodelist assumes a single vector of node labels/ids. Numeric ids are generated by the function that are used when creating the network objects.

# Currently Supported Packages (Will Add Pajek, ORA, UCINet, etc)
  support_packages <- c('igraph', 'network')
  
netwrite <- function(nodelist=FALSE, weights=FALSE, i_elements, j_elements, package='igraph', missing_code=99999, 
                     weight_type='frequency', directed='TRUE', net_name='network') {
  # Installing Necessary Packages 
    list.of.packages <- c('dplyr')
    new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
    if(length(new.packages)) install.packages(new.packages)
    rm(list.of.packages, new.packages)
  
  # Creating Canonical Node and Edgelists
    if(weights==FALSE){
      edgelist <-as.data.frame(cbind(i_elements, j_elements))
      edgelist <-cbind(edgelist, rep(1,nrow(edgelist)))
      colnames(edgelist)[[3]] <- c('weight')
    }else{
      edgelist <-as.data.frame(cbind(i_elements, j_elements, weights))
    }
    
    edgelist <- edgelist[!(rowSums(is.na(edgelist))), ]
    edgelist <- edgelist[edgelist$i_elements != missing_code & edgelist$j_elements != missing_code, ] 
    edgelist <- cbind(seq(1,nrow(edgelist), 1), edgelist)
    colnames(edgelist)[[1]] <- c('Obs_ID')
  
    if(nodelist==FALSE) {
      nodes <- as.data.frame(sort(unique(c(edgelist$i_elements, edgelist$j_elements))))
      nodes <- cbind(seq(1,nrow(nodes),1), nodes)
      colnames(nodes) <- c('id', 'label')
      
      senders <- edgelist[c(1:2)]
      colnames(senders)[[2]] <- c('label')
      senders <- dplyr::left_join(senders, nodes, by='label')
      colnames(senders)[c(2,3)] <- c('i_elements', 'i_id')
      
      targets <- edgelist[c(1,3,4)]
      colnames(targets)[[2]] <- c('label')
      targets <- dplyr::left_join(targets, nodes, by='label')
      colnames(targets)[c(2,4)] <- c('j_elements', 'j_id')
      targets <- targets[c(1,2,4,3)]
      
      edgelist <- dplyr::left_join(senders, targets, by='Obs_ID')
      
      edgelist <- edgelist[order(edgelist$i_id, edgelist$j_id), ]
      
      rm(senders, targets)
    }else{
      nodes <- nodelist[,]
      
      nodes <- cbind(seq(1,nrow(nodes),1), nodes)
      colnames(nodes) <- c('id', 'label')
      
      senders <- edgelist[c(1:2)]
      colnames(senders)[[2]] <- c('label')
      senders <- dplyr::left_join(senders, nodes, by='label')
      colnames(senders)[c(2,3)] <- c('i_elements', 'i_id')
      
      targets <- edgelist[c(1,3,4)]
      colnames(targets)[[2]] <- c('label')
      targets <- dplyr::left_join(targets, nodes, by='label')
      colnames(targets)[c(2,4)] <- c('j_elements', 'j_id')
      targets <- targets[c(1,2,4,3)]
      
      edgelist <- dplyr::left_join(senders, targets, by='Obs_ID')
      
      edgelist <- edgelist[order(edgelist$i_id, edgelist$j_id), ]
      
      rm(senders, targets)
    }
    
  # igraph
    if(package=='igraph') {
      # Installing Necessary Packages 
        list.of.packages <- c('igraph')
        new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
        if(length(new.packages)) install.packages(new.packages)
        rm(list.of.packages, new.packages)
      
      # Make Zero-Indexed
        nodes$id <- nodes$id - 1
        edgelist$i_id <- edgelist$i_id - 1
        edgelist$j_id <- edgelist$j_id - 1
        
      # Make Weights Reflect Frequency Rather than Distance
        if(weight_type == 'frequency') {
          edgelist$weight <- 1/edgelist$weight
        }else{
          edgelist$weight <- edgelist$weight
        }
        
      # Creating igraph object
        colnames(nodes)[[2]] <- c('attr')
        g <- igraph::graph_from_data_frame(d = edgelist[c(3,5)], directed = F, vertices = nodes) 
        
      # Adding edge weights
        igraph::edge.attributes(g)$weight <- edgelist$weight
        
    }else{
      edgelist <- edgelist[,]
    }
    
  # networks
    if(package=='network') {
      # Installing Necessary Packages 
        list.of.packages <- c('network')
        new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
        if(length(new.packages)) install.packages(new.packages)
        rm(list.of.packages, new.packages)
        
      # Make Weights Reflect Distance Rather than Frequency
        if(weight_type != 'frequency') {
          edgelist$weight <- 1/edgelist$weight
        }else{
          edgelist$weight <- edgelist$weight
        }
      
      # Creating sna networks to isolate network components
        g <- network::network.initialize(nrow(nodes), directed = as.logical(directed))
        
      # Adding Edges
        el <- edgelist[c(3,5)]
        el[] <- lapply(el, as.character)
        g <- network::add.edges(g, el[[1]],el[[2]])
        
      # Adding Weights
        network::set.edge.value(g,"weight", edgelist$weight)
    }else{
      edgelist <- edgelist
    }
  
  # Outputting Network Objects
    assign(x = 'edgelist', value = edgelist,.GlobalEnv)  
    assign(x = 'nodelist', value = nodes,.GlobalEnv)  
    assign(x = net_name, value = g,.GlobalEnv)  
}

netwrite(nodelist=FALSE, weights=FALSE, community_1$ego_nid, community_1$alter_id, package='network', missing_code=99999, 
         weight_type='frequency', directed='FALSE', net_name='network')

plot(network)

###############
#   netread   #
###############

#############
#   NOTES   #
#############


