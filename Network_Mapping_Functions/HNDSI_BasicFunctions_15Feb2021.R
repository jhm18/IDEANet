# HNDSI Basic Network Function Prototypes
# Jonathan H. Morgan
# 22 September 2021

# Basic Functions: More Functions to Be Added
#   netread
#   netwrite

#########################
#   GENERAL FUNCTIONS   #
#########################

#Options
options(stringsAsFactors = FALSE)
options(mc.cores = parallel::detectCores())

###############################
#   EXAMPLE CASE: AHS_WPVAR   #
###############################

setwd('/Users/jonathan.h.morgan/Desktop/DNAC/IDEANet/Data_Scripts')
import_data <- function(file_csv) {
  
  # Installing Necessary Packages 
    list.of.packages <- c('readr')
    new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
    if(length(new.packages)) install.packages(new.packages)
    rm(list.of.packages, new.packages)
    
  # Reading-In CSV with readr
    file_csv <- paste0(file_csv, '.csv')
    base_data <- readr::read_csv(file_csv, col_names = TRUE)
    
  # Creating Stacked Edgelist
    communities <- vector('list', length(unique(base_data$commcnt)))
    community_ids <- sort(unique(base_data$commcnt))
    names(communities) <- community_ids
    
    for (i in seq_along(communities)) {
      community <- base_data[base_data$commcnt == community_ids[[i]], ]
      egos <- sort(unique(community$ego_nid))
      
      alters <- vector('list', length(egos))
      names(alters) <- egos
      
      for (j in seq_along(egos)) {
        ego <- community[community$ego_nid == egos[[j]], ]
        m_friends <- as.data.frame(as.integer(ego[,c(4:8)]))
        m_friends <- cbind('Male', m_friends)
        colnames(m_friends) <- c('gender','alter_id')
        
        f_friends <- as.data.frame(as.integer(ego[,c(14:18)]))
        f_friends <- cbind('Female', f_friends)
        colnames(f_friends) <- c('gender','alter_id')
        
        alter_net <- rbind(m_friends, f_friends)
        alter_net <- cbind(egos[[j]], alter_net)
        alter_net <- cbind(community_ids[[i]], alter_net)
        colnames(alter_net)[c(1:2)] <- c('commcnt', 'ego_nid')
        
        alters[[j]] <- alter_net
        
        rm(alter_net, ego, m_friends, f_friends)
      }
      
      communities[[i]] <- do.call("rbind", alters)
      
      rm(community, egos, alters)
    }
  
  # Assigning communities edglist to the Global Environment
    assign(x = 'communities_edgelist', value = communities,.GlobalEnv)  
    
  return(base_data)
}

base_data <- import_data('ahs_wpvar')

# Focusing on Community One for Demonstration Purposes
  community_1 <- communities_edgelist[[1]]
  
################
#   netwrite   #
################
  
# Notes:
#   nodelist assumes a single vector of node labels/ids. Numeric ids are generated by the function that are used when creating the network objects.
#   https://igraph.org/r/doc/get.edge.ids.html
  
# Currently Supported Packages (Will Add Pajek, ORA, UCINet, etc)
# Starting Adding Default Metrics that Come with the Nodes File, and start Developing an attractive Visual Summary

# System Measures
  # Degree Distribution
  # Number of Components 
  # Proportion Largest Component
  # Diameter
  # Average Euclidean Distance
  # Clustering Coefficient
  # Triad Census
  # Flow Hiearchy (Directed): Flow hierarchy is defined as the fraction of edges not participating in cycles in a directed graph
  
  support_packages <- c('igraph', 'network')
  
  netwrite <- function(data_type = c('edgelist'), adjacency_matrix=FALSE, adjacency_list=FALSE,
                       nodelist=FALSE, i_elements=FALSE, j_elements=FALSE, weights=FALSE,
                       package='igraph', missing_code=99999, weight_type='frequency', 
                       directed=TRUE, net_name='network') {
    
  # Installing Necessary Packages 
    list.of.packages <- c('dplyr', 'igraph', 'network')
    new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
    if(length(new.packages)) install.packages(new.packages)
    rm(list.of.packages, new.packages)
    
  # Setting Data Type: Adjacency Matrix, Adjacency List, or Edgelist
    if(data_type == 'adjacency_matrix'){
      # Checking for ID Column
        if (dim(adjacency_matrix)[[1]] != dim(adjacency_matrix)[[2]]){
          adjacency_matrix <- adjacency_matrix[,c(2:ncol(adjacency_matrix))]
        }else{
          adjacency_matrix <- adjacency_matrix[,]
        }    
      
      # Generating Network Object
        if (package == 'igraph') {
          if(directed == TRUE){
            # Generating directed graph
              g <- igraph::graph_from_adjacency_matrix(adjacency_matrix, mode=c('directed'), diag = TRUE)
              
            # Creating Nodes File with Node-Level Measures
              edges <- as.data.frame(igraph::as_edgelist(g, names=FALSE))
              nodes <- as.data.frame(sort(unique(c(edges$V1, edges$V2))))
              colnames(nodes) <- c('id')
              nodes$id <- nodes$id - 1
              
            # Adding Node-Level Measures
              total_degree <- igraph::degree(g, mode='all', loops=FALSE)
              in_degree <- igraph::degree(g, mode='in', loops=FALSE)
              out_degree <- igraph::degree(g, mode='out', loops=FALSE)
              closeness <- igraph::closeness(g, mode='in')
              betweenness <- igraph::betweenness(g, directed=as.logical(directed))
              bonpow <- igraph::bonpow(g, loops=FALSE)
              eigen_cen <- as.numeric(igraph::eigen_centrality(g, directed=as.logical(directed))[[1]])
              nodes <- as.data.frame(cbind(nodes, total_degree, in_degree, out_degree, closeness, betweenness, bonpow, eigen_cen))
          }else{
            # Generating undirected graph
              g <- igraph::graph_from_adjacency_matrix(adjacency_matrix, mode=c('undirected'), diag = FALSE)
              
              # Creating Nodes File with Node-Level Measures
              edges <- as.data.frame(igraph::as_edgelist(g, names=FALSE))
              nodes <- as.data.frame(sort(unique(c(edges$V1, edges$V2))))
              colnames(nodes) <- c('id')
              nodes$id <- nodes$id - 1
              
              # Adding Node-Level Measures
              total_degree <- igraph::degree(g, mode='all', loops=FALSE)
              in_degree <- igraph::degree(g, mode='in', loops=FALSE)
              out_degree <- igraph::degree(g, mode='out', loops=FALSE)
              closeness <- igraph::closeness(g, mode='in')
              betweenness <- igraph::betweenness(g, directed=as.logical(directed))
              bonpow <- igraph::bonpow(g, loops=FALSE)
              eigen_cen <- as.numeric(igraph::eigen_centrality(g, directed=as.logical(directed))[[1]])
              nodes <- as.data.frame(cbind(nodes, total_degree, in_degree, out_degree, closeness, betweenness, bonpow, eigen_cen))
            
            # Creating Nodes File with Node-Level Measures
              edges <- as.data.frame(igraph::as_edgelist(g, names=FALSE))
              nodes <- as.data.frame(sort(unique(c(edges$V1, edges$V2))))
              colnames(nodes) <- c('id')
              nodes$id <- nodes$id - 1
            
            # Adding Node-Level Measures
              total_degree <- igraph::degree(g, mode='all', loops=FALSE)
              in_degree <- igraph::degree(g, mode='in', loops=FALSE)
              out_degree <- igraph::degree(g, mode='out', loops=FALSE)
              closeness <- igraph::closeness(g, mode='in')
              betweenness <- igraph::betweenness(g, directed=as.logical(directed))
              bonpow <- igraph::bonpow(g, loops=FALSE)
              eigen_cen <- as.numeric(igraph::eigen_centrality(g, directed=as.logical(directed))[[1]])
              nodes <- as.data.frame(cbind(nodes, total_degree, in_degree, out_degree, closeness, betweenness, bonpow, eigen_cen))
          }
        }else if (package == 'network'){
          if(directed == TRUE){
            # Outputting a directed graph
              g <- network::as.network(adjacency_matrix, matrix.type = "adjacency", directed = TRUE)
            
            # Specifying network metric commands
              if (directed == TRUE) {
                gmode <- 'digraph'
                cmode <- 'directed'
              }else{
                gmode <- 'graph'
                cmode <- 'undirected'
              }
              
            # Extracting nodes
              edges <- network::as.edgelist(g)
              nodes <- as.data.frame(sort(unique(c(edges[,1], edges[,2]))))
              colnames(nodes) <- c('id')
            
            # Adding node-level measures
              total_degree <- sna::degree(g, gmode=gmode, cmode='freeman')
              in_degree <- sna::degree(g, gmode=gmode, cmode='indegree')
              out_degree <- sna::degree(g, gmode=gmode, cmode='outdegree')
              closeness <- sna::closeness(g, gmode=gmode, cmode="gil-schmidt")
              betweenness <- sna::betweenness(g, gmode=gmode, cmode=cmode)
              bonpow <- as.numeric(sna::bonpow(g, gmode=gmode))
              eigen_cen <- sna::evcent(g, gmode=gmode)
              nodes <- as.data.frame(cbind(nodes, total_degree, in_degree, out_degree, closeness, betweenness, bonpow, eigen_cen))
          }else{
            # Outputting undirected graph
              g <- network::as.network(adjacency_matrix, matrix.type = "adjacency", directed = FALSE)
            
            # Specifying network metric commands
              if (directed == TRUE) {
                gmode <- 'digraph'
                cmode <- 'directed'
              }else{
                gmode <- 'graph'
                cmode <- 'undirected'
              }
              
            # Extracting nodes
              edges <- network::as.edgelist(g)
              nodes <- as.data.frame(sort(unique(c(edges[,1], edges[,2]))))
              colnames(nodes) <- c('id')
              
            # Adding node-level measures
              total_degree <- sna::degree(g, gmode=gmode, cmode='freeman')
              in_degree <- sna::degree(g, gmode=gmode, cmode='indegree')
              out_degree <- sna::degree(g, gmode=gmode, cmode='outdegree')
              closeness <- sna::closeness(g, gmode=gmode, cmode="gil-schmidt")
              betweenness <- sna::betweenness(g, gmode=gmode, cmode=cmode)
              bonpow <- as.numeric(sna::bonpow(g, gmode=gmode))
              eigen_cen <- sna::evcent(g, gmode=gmode)
              nodes <- as.data.frame(cbind(nodes, total_degree, in_degree, out_degree, closeness, betweenness, bonpow, eigen_cen))
          }
        }else{
          print('Network package not supported.')
        }
      
      # Outputting Network Object to the Global Environment
        assign(x = net_name, value = g,.GlobalEnv)
        assign(x = 'nodes', value = nodes, .GlobalEnv)
    }else if(data_type == 'adjacency_list'){
      # Is the adjacency list a list
        if(class(adjacency_list) == 'list'){
          g <- igraph::graph_from_adj_list(adj_list, mode="out")
        }else{
          # Converting to a list
            adj_list <- vector('list', dim(adjacency_list)[[1]])
            names(adj_list) <- as.character(adjacency_list[,1])
            for(i in seq_along(adj_list)){
              adj_row <- unique(as.integer(strsplit(adjacency_list[i,2], ' ')[[1]]))
              adj_list[[i]] <- vector('list', length(adj_row))
              for(j in seq_along(adj_row)) {
                adj_list[[i]][[j]] <- adj_row[[j]]
              }
              rm(adj_row)
            }
          
          # Generating network from adjacency list
            g <- igraph::graph_from_adj_list(adj_list, mode="out")
        }
      
      # Generating network object
        if (package == 'igraph') {
          # Copying igraph object
            g <- g
          
          # Creating Nodes File with Node-Level Measures
            edges <- as.data.frame(igraph::as_edgelist(g, names=FALSE))
            nodes <- as.data.frame(sort(unique(c(edges$V1, edges$V2))))
            colnames(nodes) <- c('id')
            nodes$id <- nodes$id - 1
            
          # Adding Node-Level Measures
            total_degree <- igraph::degree(g, mode='all', loops=FALSE)
            in_degree <- igraph::degree(g, mode='in', loops=FALSE)
            out_degree <- igraph::degree(g, mode='out', loops=FALSE)
            closeness <- igraph::closeness(g, mode='in')
            betweenness <- igraph::betweenness(g, directed=as.logical(directed))
            bonpow <- igraph::bonpow(g, loops=FALSE)
            eigen_cen <- as.numeric(igraph::eigen_centrality(g, directed=as.logical(directed))[[1]])
            nodes <- as.data.frame(cbind(nodes, total_degree, in_degree, out_degree, closeness, betweenness, bonpow, eigen_cen))
        }else if (package == 'network') {
          # Getting Edgelist: iGraph
            edges <- as.data.frame(igraph::as_edgelist(g, names=FALSE))
            colnames(edges) <- c('i_id', 'j_id')
          
          # Checking if there are edge values
            if (length(igraph::get.edge.attribute(g)) > 0) {
              edge_values <- as.data.frame(igraph::get.edge.attribute(g))
              edges <- cbind(edges, edge_values)
              rm(edge_values)
            }else{
              edges$weight <- 1
            }
          
          # Extracting nodelist
            adj_ids <- igraph::get.adjlist(g, mode='all')
            nodes <- as.data.frame(seq(1, length(adj_ids), 1))
            colnames(nodes)[[1]] <- c('id')
            rm(adj_ids)
            
          # Generating network data object
            g <- network::network.initialize(nrow(nodes), directed = as.logical(directed))
            
            el <- edges[,c(1,2)]
            el[,1] <- as.character(el[,1])
            el[,2] <- as.character(el[,2])
            g <- network::add.edges(g, el[,1], el[,2])
            
          # Adding Node-Level Measures
            if (directed == TRUE) {
              gmode <- 'digraph'
              cmode <- 'directed'
            }else{
              gmode <- 'graph'
              cmode <- 'undirected'
            }
            
            total_degree <- sna::degree(g, gmode=gmode, cmode='freeman')
            in_degree <- sna::degree(g, gmode=gmode, cmode='indegree')
            out_degree <- sna::degree(g, gmode=gmode, cmode='outdegree')
            closeness <- sna::closeness(g, gmode=gmode, cmode="gil-schmidt")
            betweenness <- sna::betweenness(g, gmode=gmode, cmode=cmode)
            bonpow <- as.numeric(sna::bonpow(g, gmode=gmode))
            eigen_cen <- sna::evcent(g, gmode=gmode)
            nodes <- as.data.frame(cbind(nodes, total_degree, in_degree, out_degree, closeness, betweenness, bonpow, eigen_cen))
        }else {
          print('Network package not supported.')
        }
        
      # Outputting network object to global environment
        assign(x = net_name, value = g,.GlobalEnv)
        assign(x = 'nodes', value = nodes, .GlobalEnv)
    }else{
      # Creating Canonical Node and Edgelists
        if(weights==FALSE){
          edgelist <-as.matrix(cbind(i_elements, j_elements))
          edgelist <-cbind(edgelist, rep(1,nrow(edgelist)))
          colnames(edgelist)[[3]] <- c('weight')
        }else{
          edgelist <-as.matrix(cbind(i_elements, j_elements, weights))
        }
      
        edgelist <- edgelist[!(rowSums(is.na(edgelist))), ]
        edgelist <- edgelist[edgelist[,1] != missing_code & edgelist[,2] != missing_code, ] 
        edgelist <- cbind(seq(1,nrow(edgelist), 1), edgelist)
        colnames(edgelist)[[1]] <- c('Obs_ID')
        
      # Adding Nodes
        if(nodelist==FALSE) {
          nodes <- as.data.frame(sort(unique(c(edgelist[,2], edgelist[,3]))))
          nodes <- cbind(seq(1,nrow(nodes),1), nodes)
          colnames(nodes) <- c('id', 'label')
          
          senders <- as.data.frame(edgelist[,c(1:2)])
          colnames(senders)[[2]] <- c('label')
          senders <- dplyr::left_join(senders, nodes, by='label')
          colnames(senders)[c(2,3)] <- c('i_elements', 'i_id')
          
          targets <- as.data.frame(edgelist[,c(1,3,4)])
          colnames(targets)[[2]] <- c('label')
          targets <- dplyr::left_join(targets, nodes, by='label')
          colnames(targets)[c(2,4)] <- c('j_elements', 'j_id')
          targets <- targets[c(1,2,4,3)]
          
          edgelist <- dplyr::left_join(senders, targets, by='Obs_ID')
          edgelist <- edgelist[order(edgelist$i_id, edgelist$j_id), ]
          edgelist <- as.matrix(edgelist)
          rm(senders, targets)
        }else{
          nodes <- nodelist[,]
          
          nodes <- cbind(seq(1,nrow(nodes),1), nodes)
          colnames(nodes) <- c('id', 'label')
          
          senders <- as.data.frame(edgelist[,c(1:2)])
          colnames(senders)[[2]] <- c('label')
          senders <- dplyr::left_join(senders, nodes, by='label')
          colnames(senders)[c(2,3)] <- c('i_elements', 'i_id')
          
          targets <- as.data.frame(edgelist[,c(1,3,4)])
          colnames(targets)[[2]] <- c('label')
          targets <- dplyr::left_join(targets, nodes, by='label')
          colnames(targets)[c(2,4)] <- c('j_elements', 'j_id')
          targets <- targets[c(1,2,4,3)]
          
          edgelist <- dplyr::left_join(senders, targets, by='Obs_ID')
          edgelist <- edgelist[order(edgelist$i_id, edgelist$j_id), ]
          edgelist <- as.matrix(edgelist)
          rm(senders, targets)
        }
        
      # Create Graph Objects
        if(package == 'igraph'){
          # Make Zero-Indexed
            nodes$id <- nodes$id - 1
            edgelist[,3] <- edgelist[,3] - 1
            edgelist[,5] <- edgelist[,5] - 1
            
          # Make Weights Reflect Frequency Rather than Distance
            if(weight_type == 'frequency') {
              edgelist[,6] <- 1/edgelist[,6]
            }else{
              edgelist[,6] <- edgelist[,6]
            }
            
          # Creating igraph object
            colnames(nodes)[[2]] <- c('attr')
            g <- igraph::graph_from_data_frame(d = edgelist[,c(3,5)], directed = as.logical(directed), vertices = nodes) 
            
          # Adding edge weights
            igraph::edge.attributes(g)$weight <- edgelist[,6]
            
          # Adding Node-Level Measures
            total_degree <- igraph::degree(g, mode='all', loops=FALSE)
            in_degree <- igraph::degree(g, mode='in', loops=FALSE)
            out_degree <- igraph::degree(g, mode='out', loops=FALSE)
            closeness <- igraph::closeness(g, mode='in')
            betweenness <- igraph::betweenness(g, directed=as.logical(directed))
            bonpow <- igraph::bonpow(g, loops=FALSE)
            eigen_cen <- as.numeric(igraph::eigen_centrality(g, directed=as.logical(directed))[[1]])
            nodes <- as.data.frame(cbind(nodes, total_degree, in_degree, out_degree, closeness, betweenness, bonpow, eigen_cen))
            
        }else if(package == 'network'){
          # Make Weights Reflect Distance Rather than Frequency
            if(weight_type != 'frequency') {
              edgelist[,6] <- 1/edgelist[,6]
            }else{
              edgelist[,6] <- edgelist[,6]
            }
          
          # Creating sna networks to isolate network components
            g <- network::network.initialize(nrow(nodes), directed = as.logical(directed))
          
          # Adding Edges
            el <- edgelist[,c(3,5)]
            el[,1] <- as.character(el[,1])
            el[,2] <- as.character(el[,2])
            g <- network::add.edges(g, el[,1], el[,2])
          
          # Adding Weights
            network::set.edge.value(g,"weight", edgelist[,6])
            
          # Adding Node-Level Measures
            if (directed == TRUE) {
              gmode <- 'digraph'
              cmode <- 'directed'
            }else{
              gmode <- 'graph'
              cmode <- 'undirected'
            }
          
            total_degree <- sna::degree(g, gmode=gmode, cmode='freeman')
            in_degree <- sna::degree(g, gmode=gmode, cmode='indegree')
            out_degree <- sna::degree(g, gmode=gmode, cmode='outdegree')
            closeness <- sna::closeness(g, gmode=gmode, cmode="gil-schmidt")
            betweenness <- sna::betweenness(g, gmode=gmode, cmode=cmode)
            bonpow <- as.numeric(sna::bonpow(g, gmode=gmode))
            eigen_cen <- sna::evcent(g, gmode=gmode)
            nodes <- as.data.frame(cbind(nodes, total_degree, in_degree, out_degree, closeness, betweenness, bonpow, eigen_cen))
        }else{
          edgelist <- edgelist[,]
        }
        
      # Outputting Network Objects
        assign(x = 'edgelist', value = edgelist,.GlobalEnv)  
        assign(x = 'nodelist', value = nodes,.GlobalEnv)  
        assign(x = net_name, value = g,.GlobalEnv)
    }
  }
    
# Edgelist Example
  netwrite(data_type = c('edgelist'), adjacency_matrix=FALSE, adjacency_list=FALSE,
           nodelist=FALSE, i_elements=community_1$ego_nid, j_elements=community_1$alter_id, weights=FALSE,
           package='igraph', missing_code=99999, weight_type='frequency', 
           directed='TRUE', net_name='net_1')
  
  plot(net_1)
  
  netwrite(data_type = c('edgelist'), adjacency_matrix=FALSE, adjacency_list=FALSE,
           nodelist=FALSE, i_elements=community_1$ego_nid, j_elements=community_1$alter_id, weights=FALSE,
           package='network', missing_code=99999, weight_type='frequency', 
           directed='TRUE', net_name='net_2')
  
  plot(net_2)

# Adjacency Matrix Example
  adj_mat <- as.matrix(net_2, matrix.type="adjacency")
  
  netwrite(data_type = c('adjacency_matrix'), adjacency_matrix=adj_mat, adjacency_list=FALSE,
           nodelist=FALSE, i_elements=FALSE, j_elements=FALSE, weights=FALSE,
           package='igraph', missing_code=99999, weight_type='frequency', 
           directed='TRUE', net_name='net_3')
  
  plot(net_3)
  
  netwrite(data_type = c('adjacency_matrix'), adjacency_matrix=adj_mat, adjacency_list=FALSE,
           nodelist=FALSE, i_elements=FALSE, j_elements=FALSE, weights=FALSE,
           package='network', missing_code=99999, weight_type='frequency', 
           directed='TRUE', net_name='net_4')
  
  plot(net_4)
  
# Adjacency List Example
  adjacency_list <- igraph::as_adj_list(net_1, mode='out')
  
  adj_list <- vector('list', length(adjacency_list))
  for (i in seq_along(adjacency_list)) {
    adj_row <- unique(as.integer(adjacency_list[[i]]))
    adj_row <- paste(adj_row, collapse = ' ')
    adj_list[[i]] <- adj_row
    rm(adj_row)
  }
  
  adj_list <- as.data.frame(do.call("rbind", adj_list))
  adj_list <- cbind(names(adjacency_list), adj_list)
  colnames(adj_list) <- c('ego', 'alters')
  
  netwrite(data_type = c('adjacency_list'), adjacency_matrix=FALSE, adjacency_list=adj_list,
           nodelist=FALSE, i_elements=FALSE, j_elements=FALSE, weights=FALSE,
           package='network', missing_code=99999, weight_type='frequency', 
           directed='TRUE', net_name='net_5')
  
  plot(net_5)
  
###############
#   netread   #
###############

netread <- function(package="network", network_object=network) {
  # Network Control Logic
    if(package == "network"){
      # Getting Edgelist
        edges <- as.data.frame(network::as.edgelist(network_object))
        colnames(edges) <- c('i_id', 'j_id')
        
      # Checking if there are edge values
        if(length(network::list.edge.attributes(network_object)[network::list.edge.attributes(network_object) != "na"]) >= 1){
          edge_attribute <- network::list.edge.attributes(network_object)[network::list.edge.attributes(network_object) != "na"]
          edge_value <- network::get.edge.value(network_object, edge_attribute, unlist = TRUE, na.omit = TRUE, null.na = FALSE, deleted.edges.omit = TRUE)
          edges$weight <- edge_value
        }else{
          edges$weight <- 1
        }
        
      # Extracting Nodelist 
        nodes <- network::get.vertex.attribute(network_object, "vertex.names")
        nodes <- as.data.frame(cbind(seq(1, length(nodes), 1), nodes))
        colnames(nodes) <- c('id', 'label')
        rm(edge_value)
    }else if (package == 'igraph'){
      # Getting Edgelist: iGraph
        edges <- as.data.frame(igraph::as_edgelist(network_object, names=FALSE))
        colnames(edges) <- c('i_id', 'j_id')
        
      # Checking if there are edge values
        if (length(igraph::get.edge.attribute(network_object)) > 0) {
         edge_values <- as.data.frame(igraph::get.edge.attribute(network_object))
         edges <- cbind(edges, edge_values)
        }else{
          edges$weight <- 1
        }
        
      # Extracting nodelist
        nodes <- as.data.frame(igraph::get.vertex.attribute(network_object))
        colnames(nodes)[[1]] <- c('id')
        nodes$id <- as.numeric(nodes$id)
        nodes$id <- nodes$id + 1
        rm(edge_values)
    } else {
      network_object <- network_object
      print('Package Not Supported')
    }
  
    # Outputting Network Objects
      assign(x = 'edges', value = edges,.GlobalEnv)  
      assign(x = 'nodes', value = nodes,.GlobalEnv)  
}

netread(package='network', network_object=network)

#############
#   NOTES   #
#############


